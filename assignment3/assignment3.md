# CS4286: Assignment3 

* Name: Zhang Deheng
* SID: 55199998

[TOC]

## 1. Security Services

## 2. Password File

* $y = H(s; password) \oplus password$: It is secure against precomputed dictionary attack since we cannot get the $password$ or $h(password)$ with a known $s$. We need to pre-compute all the possible $H(s; password)\oplus password​$
* $y = H(s) \oplus H(password):​$ It is insecure against precomputed dictionary attack since if we know $s​$, we can compute $H(password) = y \oplus H(s)​$ 
* $y = E_s(H(password)): $ It is insecure against precomputed dictionary attack since if we know $s$, we can compute $H(password) = D_s(y)$ where $D$ is the decryption of AES algorithm. 
* $y = MAC_{password}(s): $ It is secure against precomputed dictionary attack since we cannot get the $password$ or $h(password)$ with a known $s$. We need to pre-compute all the possible $MAC_{password}(s)$ 

## 3. TLS

* (a) There are 5 ciphersuites in the latest specification TLS 1.3 according to [openssl_wiki](<https://wiki.openssl.org/index.php/TLS1.3>).

  * TLS_AES_256_GCM_SHA384
  * TLS_CHACHA20_POLY1305_SHA256
  * TLS_AES_128_GCM_SHA256
  * TLS_AES_128_CCM_8_SHA256
  * TLS_AES_128_CCM_SHA256

* (b) Assume Alice ($A​$) and Bob ($B​$) are sharing a session key

  * TLS: the transport layer security protocol

  * AES_128_CCM​: Authentication and encryption algorithm is 128-bit AES operating in Counter_CBC_MAC (CCM) mode. 

  * SHA_256: The hash function is 256-bit SHA

  * The procedure of generating session keys and encrypting the data messages

    1. $A \rightarrow B: 5\ Cipher\ suites, TLS\ 1.3, R_A$ 
    2. $A \leftarrow B: TLS\_AES\_128\_CCM\_SHA256, Cert_B, R_B$ 
    3. $A \rightarrow B: \{S\}_B, AES\_128\_CCM_{K}(SHA_{256}(msgs))​$ 
    4. $A \leftarrow B: AES\_128\_CCM_{K}(SHA_{256}(msgs))​$ 
    5. $A \leftrightarrow B: AES\_128\_CCM_{K}(data)$  

    * Where
      * $R_A​$ and $R_B​$ are nonces generated by $A​$ and $B​$ respectively
      * $Cert_B​$ is the certificate of the public key of $B​$ 
      * $\{\}_B$ represents the ciphertext encrypted by $B$’s public key
      * $S$ is randomly chosen by $A$ 
      * $K = SHA_{256}(S, R_A, R_B)​$ 

## 4. Key agreement/IKE

* (a) i. Authenticity and Key agreement

  * Authenticity: $A​$ and $B​$ are not authenticated to each other since there is no freshness included in the $proof_A​$ and $proof_B​$ and the nonce encrypted by the public key is not requred to be decrypted. **Once trudy knows Alice's and Bob’s IP address**, he can intercept the message and lauch man-in-the-middle attack.  
  * Key agreement: Key agreement is achieved
    * Key control: Neither entity of $A$ and $B$ has key control. 
    * Key authentication:  $g^{ab}\ mod\ p$ is only possible to be known by only one entity for both $A$ and $B$ despite themselves (which is an implicit key authentication). 
      * However, according to the definition of key authentication, the entity that shares a key with you should be identified. If we define “identified” as “authenticated”, it is neither implicit nor explicit key authentication. 

* (a) ii. Modified protocol

  1. $A \rightarrow B: \{g^a\ mod\ p\}_{Bob}, \{“Alice”\}_{Bob}$
  2. $A \leftarrow B: \{g^b\ mod\ p\}_{Alice}, \{“Bob”\}_{Alice}, proof_B​$  
  3. $A \rightarrow B: proof_A$  

  * Where 
    * $proof_A = h(g^{ab}\ mod\ p, g^a\ mod\ p, g^b\ mod\ p, “Alice”, T_A)$  
    * $proof_B =  h(g^{ab}\ mod\ p, g^a\ mod\ p, g^b\ mod\ p, “Bob”, T_B)​$
    * $K = h(g^{ab}\ mod\ p)$
    * $T_A$ and $T_B$ are timestamps generated by Alice and Bob respectively. (We assume they have synchronized clocks)
  * In this way authenticity between $A$ and $B$ is provided, where data origin authentication is provided by public key encryption, and freshness is provided by the timestamp. Key agreement is also provided. 

* (b) This version is insecure because once the attacker Trudy ($T$) can intercept the first message, he can lauch a man-in-the-middle attack to establish a key with one of the participant $A$ while pretending to be $B​$ as shown below. 

  1. $A \rightarrow T: “Alice”, “Bob”, g^a\ mod\ p​$ 
  2. $T \rightarrow B: “Trudy”, “Bob”, g^a\ mod\ p$ 
  3. $T \leftarrow B: “Bob”, “Trudy”, g^b\ mod\ p, [g^a\ mod\ p]_B​$ 
  4. $A \leftarrow T: “Bob”, “Alice”, g^b\ mod\ p, [g^a\ mod\ p]_B​$
  5. $A \rightarrow  T: “Alice”, “Bob”, [g^b\ mod\ p, g^a\ mod\ p]_A$ 

## 5. IPSec

* (a) The tunnel mode should be used. Because even in ESP mode the original IP header is not encrypted and we can see who is the actual sender receiver is. Transport mode is designed for host-to-host instead of gateway-to-gateway. For tunnel mode, the header inside the intranet (e.g. 10.1.1.1) will be changed to a new header outside the intranet (e.g. 4.3.2.1). And by using ESP, confidentiality of the original header will be provided. 

* (b) We name the data in the transport layer as packet, in the network layer as frame. 

  1. Node 10.1.1.5 generates a frame with IP header (with source IP address 10.1.1.5 and target IP address 10.2.1.6), TCP header, and application layer data. The frame is sent to the intranet of 10.1.1.1. 
     $$
     frame=[source: 10.1.1.5, dest: 10.2.1.6, ...| packet]
     $$
     

  2. The router (10.1.1.1 - 4.3.2.1) GW encapsulate the frame adding a new IP header (with source IP address 4.3.2.1 and target IP address 8.7.6.5). Then, 

     * if AH is used: authenticate all the immutable fileds in the new IP header as well as the original packet.
       $$
       frame=[|source: 4.3.2.1, dest: 8.7.6.5, ...|AH|(source: 10.1.1.5, dest: 10.2.1.6, ...| packet)]
       $$

     * if ESP is used: authenticate and encrypt the original packet, append the ESP auth field. 
       $$
       frame=[|source: 4.3.2.1, dest: 8.7.6.5, ...|ESP|(source: 10.1.1.5, dest: 10.2.1.6, ...| packet)|]
       $$

  3. The router (10.2.1.1 - 8.7.6.5) GW de-capsulate the packet (strip extra headers) and inject the packet to the intra net of 10.2.1.1. The detail process can be divided into two cases:

     * if AH is used: verify all the immutable fileds in the new IP header as well as the original packet. Remove the new IP header and the AH header. 
     * if ESP is used: verify and decrypt the original packet. Remove the ESP auth field, new IP header, and the ESP header. 

     $$
     [source: 10.1.1.5, dest: 10.2.1.6| data]
     $$

  4. Node 10.2.1.6 receives the packet. 

  * Note that the routing tables for the two routers needs to direct the packets to the GWs so these could be directed. 

## 6. Password File



## 7. PGP eMail